/**
 * Integration Tests for Proofreader Error Scenarios and Recovery
 */

import { describe, it, expect, beforeEach, afterEach, vi, Mock } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Proofreader } from '../components/ui/proofreader';
import { proofreaderErrorHandler } from '../lib/proofreader-error-handling';
import { proofreaderRecoveryService } from '../lib/proofreader-recovery-service';

// Mock dependencies
vi.mock('../lib/content-retrieval-service', () => ({
  contentRetrievalService: {
    retrieveAllContent: vi.fn(),
    getIntegrationStatus: vi.fn(),
    subscribeToContentChanges: vi.fn(() => () => {})
  }
}));

vi.mock('sonner', () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
    warning: vi.fn(),
    info: vi.fn()
  }
}));

global.fetch = vi.fn();
global.navigator = { onLine: true } as any;
global.localStorage = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn()
} as any;

describe('Proofreader Error Scenarios Integration Tests', () => {
  const mockProps = {
    isOpen: true,
    onClose: vi.fn(),
    currentConversation: { title: 'Test Conversation', id: 'test-conv-id' }
  };

  const mockFetch = fetch as Mock;

  beforeEach(() => {
    vi.clearAllMocks();
    (localStorage.getItem as Mock).mockReturnValue(null);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Network Error Scenarios', () => {
    it('should handle network errors during concern loading with retry', async () => {
      // First call fails with network error
      mockFetch
        .mockRejectedValueOnce(new Error('Failed to fetch'))
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ concerns: [] })
        });

      render(<Proofreader {...mockProps} />);

      await waitFor(() => {
        expect(mockFetch).toHaveBeenCalledTimes(2); // Initial call + retry
      });
    });

    it('should show offline indicator when network is unavailable', async () => {
      // Mock offline state
      Object.defineProperty(navigator, 'onLine', {
        writable: true,
        value: false
      });

      render(<Proofreader {...mockProps} />);

      await waitFor(() => {
        expect(screen.getByText('Offline')).toBeInTheDocument();
      });
    });

    it('should use cached data when network fails', async () => {
      const cachedConcerns = [
        {
          id: 'cached-concern',
          conversationId: 'test-conv-id',
          category: 'clarity' as any,
          severity: 'medium' as any,
          title: 'Cached Concern',
          description: 'This is from cache',
          status: 'to_be_done' as any,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];

      // Mock cache to return data
      vi.spyOn(proofreaderRecoveryService, 'getCachedConcerns').mockReturnValue(cachedConcerns);
      
      // Mock fetch to fail
      mockFetch.mockRejectedValue(new Error('Network error'));

      render(<Proofreader {...mockProps} />);

      await waitFor(() => {
        expect(screen.getByText('Cached Concern')).toBeInTheDocument();
        expect(screen.getByText('Cached')).toBeInTheDocument();
      });
    });
  });

  describe('AI Service Error Scenarios', () => {
    it('should handle AI service errors with fallback analysis', async () => {
      const { contentRetrievalService } = await import('../lib/content-retrieval-service');
      
      // Mock content retrieval success
      (contentRetrievalService.retrieveAllContent as Mock).mockResolvedValue({
        success: true,
        builderContent: {
          content: 'This is a test document with sufficient content for analysis testing.'
        },
        ideaDefinitions: []
      });

      // Mock AI service failure followed by fallback success
      vi.spyOn(proofreaderRecoveryService, 'performAnalysisWithRecovery').mockResolvedValue({
        success: true,
        concerns: [
          {
            id: 'fallback-concern',
            conversationId: 'test-conv-id',
            category: 'completeness' as any,
            severity: 'low' as any,
            title: 'Basic Analysis Result',
            description: 'Generated by fallback analysis',
            status: 'to_be_done' as any,
            createdAt: new Date(),
            updatedAt: new Date()
          }
        ],
        analysisMetadata: {
          totalConcerns: 1,
          concernsByCategory: { completeness: 1 },
          concernsBySeverity: { low: 1 },
          analysisTime: 500,
          contentLength: 100,
          ideaDefinitionsUsed: 0,
          fallbackUsed: true,
          offlineMode: true
        }
      });

      render(<Proofreader {...mockProps} />);

      // Click analyze button
      const analyzeButton = screen.getByText('Analyze Content');
      fireEvent.click(analyzeButton);

      await waitFor(() => {
        expect(screen.getByText('Basic Analysis Result')).toBeInTheDocument();
        expect(screen.getByText('Basic Mode')).toBeInTheDocument();
      });
    });

    it('should show appropriate error message for AI service failures', async () => {
      const { contentRetrievalService } = await import('../lib/content-retrieval-service');
      
      (contentRetrievalService.retrieveAllContent as Mock).mockResolvedValue({
        success: true,
        builderContent: { content: 'Test content' },
        ideaDefinitions: []
      });

      // Mock AI service failure
      vi.spyOn(proofreaderRecoveryService, 'performAnalysisWithRecovery').mockResolvedValue({
        success: false,
        error: 'AI service is temporarily unavailable. Please try again later.'
      });

      render(<Proofreader {...mockProps} />);

      const analyzeButton = screen.getByText('Analyze Content');
      fireEvent.click(analyzeButton);

      await waitFor(() => {
        expect(screen.getByText(/AI service is temporarily unavailable/)).toBeInTheDocument();
      });
    });
  });

  describe('Content Error Scenarios', () => {
    it('should handle insufficient content error', async () => {
      const { contentRetrievalService } = await import('../lib/content-retrieval-service');
      
      (contentRetrievalService.retrieveAllContent as Mock).mockResolvedValue({
        success: true,
        builderContent: { content: 'Short' }, // Too short
        ideaDefinitions: []
      });

      render(<Proofreader {...mockProps} />);

      const analyzeButton = screen.getByText('Analyze Content');
      fireEvent.click(analyzeButton);

      await waitFor(() => {
        expect(screen.getByText(/Content is too short for meaningful analysis/)).toBeInTheDocument();
      });
    });

    it('should handle missing content error', async () => {
      const { contentRetrievalService } = await import('../lib/content-retrieval-service');
      
      (contentRetrievalService.retrieveAllContent as Mock).mockResolvedValue({
        success: false,
        error: 'No content available for analysis'
      });

      render(<Proofreader {...mockProps} />);

      const analyzeButton = screen.getByText('Analyze Content');
      fireEvent.click(analyzeButton);

      await waitFor(() => {
        expect(screen.getByText(/No content available for analysis/)).toBeInTheDocument();
      });
    });
  });

  describe('Status Update Error Scenarios', () => {
    it('should handle status update failures with retry', async () => {
      // Mock initial concerns load
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({
          concerns: [
            {
              id: 'test-concern',
              conversation_id: 'test-conv-id',
              category: 'clarity',
              severity: 'medium',
              title: 'Test Concern',
              description: 'Test description',
              status: 'to_be_done',
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            }
          ]
        })
      });

      // Mock status update failure then success
      vi.spyOn(proofreaderRecoveryService, 'updateConcernStatusWithRecovery')
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({ success: true });

      render(<Proofreader {...mockProps} />);

      await waitFor(() => {
        expect(screen.getByText('Test Concern')).toBeInTheDocument();
      });

      // Try to update status (this would require more complex interaction simulation)
      // For now, we'll test the error handling logic directly
      const error = proofreaderErrorHandler.classifyError(
        new Error('Network error'),
        'status_update',
        'test-conv-id'
      );

      expect(error.type).toBe('network_error');
      expect(error.retryable).toBe(true);
    });

    it('should queue status updates when offline', async () => {
      // Mock offline state
      Object.defineProperty(navigator, 'onLine', {
        writable: true,
        value: false
      });

      const result = await proofreaderRecoveryService.updateConcernStatusWithRecovery(
        'test-concern-id',
        'addressed' as any
      );

      expect(result.success).toBe(true);
      expect(proofreaderRecoveryService.getPendingOperationsCount()).toBeGreaterThan(0);
    });
  });

  describe('Rate Limiting Scenarios', () => {
    it('should handle rate limit errors with appropriate delays', async () => {
      const rateLimitError = new Error('Rate limit exceeded');
      const classified = proofreaderErrorHandler.classifyError(
        rateLimitError,
        'analysis',
        'test-conv-id'
      );

      expect(classified.type).toBe('rate_limit_error');
      expect(classified.retryable).toBe(true);

      const delay = proofreaderErrorHandler.getRetryDelay(classified, 0);
      expect(delay).toBeGreaterThan(1000); // Should have longer delay for rate limits
    });

    it('should show rate limit guidance in UI', async () => {
      render(<Proofreader {...mockProps} />);

      // Simulate rate limit error in state
      const rateLimitError = proofreaderErrorHandler.classifyError(
        new Error('Rate limit exceeded'),
        'analysis',
        'test-conv-id'
      );

      // This would require more complex state manipulation in a real test
      // For now, we verify the error classification works correctly
      expect(rateLimitError.userMessage).toContain('Rate limit exceeded');
    });
  });

  describe('Recovery and Sync Scenarios', () => {
    it('should sync pending operations when connection is restored', async () => {
      // Queue some operations while offline
      proofreaderRecoveryService.queueOperation({
        type: 'status_update',
        data: { concernId: 'test-concern', status: 'addressed' }
      });

      expect(proofreaderRecoveryService.getPendingOperationsCount()).toBe(1);

      // Mock successful sync
      mockFetch.mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ success: true })
      });

      // Simulate connection restoration
      await (proofreaderRecoveryService as any).handleConnectionRestored();

      expect(proofreaderRecoveryService.getPendingOperationsCount()).toBe(0);
    });

    it('should show pending operations count in UI', async () => {
      // Queue an operation
      proofreaderRecoveryService.queueOperation({
        type: 'status_update',
        data: { concernId: 'test-concern', status: 'addressed' }
      });

      render(<Proofreader {...mockProps} />);

      await waitFor(() => {
        expect(screen.getByText('1 pending')).toBeInTheDocument();
      });
    });
  });

  describe('Error History and Monitoring', () => {
    it('should track error history', () => {
      const error1 = new Error('First error');
      const error2 = new Error('Second error');

      proofreaderErrorHandler.classifyError(error1, 'operation1');
      proofreaderErrorHandler.classifyError(error2, 'operation2');

      const history = proofreaderErrorHandler.getErrorHistory();
      expect(history.length).toBe(2);
    });

    it('should show error statistics', () => {
      // Generate some test errors
      proofreaderErrorHandler.classifyError(new Error('Network error'), 'analysis');
      proofreaderErrorHandler.classifyError(new Error('AI service error'), 'analysis');

      const stats = proofreaderErrorHandler.getErrorStatistics(60);
      expect(stats.totalErrors).toBeGreaterThan(0);
      expect(stats.errorsByType).toHaveProperty('network_error');
      expect(stats.errorsByOperation).toHaveProperty('analysis');
    });

    it('should display recent errors in UI', async () => {
      render(<Proofreader {...mockProps} />);

      // The error history display would be tested here
      // This requires the component to have errors in its state
      await waitFor(() => {
        // Check if error history section exists when there are errors
        const errorHistorySection = screen.queryByText(/Recent errors/);
        // This might not be visible if no errors exist
      });
    });
  });

  describe('Graceful Degradation', () => {
    it('should provide basic functionality when AI is unavailable', async () => {
      const { contentRetrievalService } = await import('../lib/content-retrieval-service');
      
      (contentRetrievalService.retrieveAllContent as Mock).mockResolvedValue({
        success: true,
        builderContent: {
          content: 'This is a test document that should be analyzed using basic methods when AI is not available.'
        },
        ideaDefinitions: []
      });

      // Mock offline analysis
      const offlineResult = await (proofreaderRecoveryService as any).performOfflineAnalysis({
        conversationId: 'test-conv-id',
        documentContent: 'This is a test document that should be analyzed using basic methods when AI is not available.',
        ideaDefinitions: []
      });

      expect(offlineResult.success).toBe(true);
      expect(offlineResult.analysisMetadata?.fallbackUsed).toBe(true);
      expect(offlineResult.concerns).toBeDefined();
    });

    it('should maintain core functionality during service degradation', async () => {
      // Test that basic operations still work when services are degraded
      const cachedConcerns = [
        {
          id: 'cached-concern',
          conversationId: 'test-conv-id',
          category: 'clarity' as any,
          severity: 'medium' as any,
          title: 'Cached Concern',
          description: 'This works offline',
          status: 'to_be_done' as any,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      ];

      proofreaderRecoveryService.cacheConcerns('test-conv-id', cachedConcerns);
      const retrieved = proofreaderRecoveryService.getCachedConcerns('test-conv-id');

      expect(retrieved).toEqual(cachedConcerns);
    });
  });

  describe('User Experience During Errors', () => {
    it('should provide clear error messages and recovery options', () => {
      const networkError = proofreaderErrorHandler.classifyError(
        new Error('Network request failed'),
        'analysis',
        'test-conv-id'
      );

      const userMessage = proofreaderErrorHandler.createUserFriendlyMessage(networkError);
      
      expect(userMessage).toContain('Network connection failed');
      expect(userMessage).toContain('Suggestions:');
      expect(userMessage).toContain('Check your internet connection');
    });

    it('should show appropriate loading states during recovery', async () => {
      render(<Proofreader {...mockProps} />);

      // The loading states would be tested by simulating various scenarios
      // and checking for loading indicators, progress bars, etc.
      await waitFor(() => {
        // Check for loading skeleton or spinner
        const loadingElements = screen.queryAllByTestId(/loading|skeleton/);
        // Loading elements might not be present if loading is complete
      });
    });
  });
});